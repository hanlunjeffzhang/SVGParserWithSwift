////  XMLParser.swift//  SVGParser-Test-II////  Created by Jeff on 2014-08-08.//  Copyright (c) 2014 Jeff. All rights reserved.//import UIKit//var titleHolder:[String] = [];class XMLParser: NSObject, NSXMLParserDelegate{        var element = NSString();    var standardXMLParser = NSXMLParser();    var urlwithURLDataType:NSURL = NSURL();    var viewing:DrawingView = DrawingView();    var titleText:UINavigationItem = UINavigationItem();    //    init(url:String, displayView:DrawingView) {//        super.init();//        urlwithURLDataType = NSURL.URLWithString(url);//        viewing = displayView;//        parsingStarter();//    };        func initWithURL(#xmlurl:String, viewToDrawOn:DrawingView, titleView:UINavigationItem) -> AnyObject {        urlwithURLDataType = NSURL(string: xmlurl);        viewing = viewToDrawOn;        titleText = titleView;        println("testing1");        parsingStarter();            return self    }        func parsingStarter () {        standardXMLParser = NSXMLParser(contentsOfURL: urlwithURLDataType)        standardXMLParser.delegate = self;        standardXMLParser.parse();    }         //Potential Problem Below        func parser(parser: NSXMLParser!, didStartElement elementName: String!, namespaceURI: String!, qualifiedName qName: String!, attributes attributeDict: NSDictionary!){                println("point1");                element = elementName;        if (element.isEqualToString("circle")){                        var cx:CGFloat = CGFloat((attributeDict.valueForKey("cx") as NSString).floatValue), radius:CGFloat = CGFloat((attributeDict.valueForKey("r") as NSString).floatValue), cy:CGFloat = CGFloat((attributeDict.valueForKey("cy") as NSString).floatValue);            var localStrokeWidth = attributeDict.valueForKey("stroke-width"), fill:AnyObject? = attributeDict.valueForKey("fill"), stroke:AnyObject? = attributeDict.valueForKey("stroke");                        var circleConvert = dataAnalysis.circleCoordinatesConverter(cx, oldy: cy, radius: radius);            dataAnalysis.strokeFillSet(fill?, stroke: stroke?, strokeWidthIntake:localStrokeWidth);                viewing.circleCreate(x: circleConvert.newx, y: circleConvert.newy, widthDia: radius*2, heightDia: radius*2, redFill: redScheme, greenFill: greenScheme, blueFill: blueScheme, alphaFill: alphaScheme, strokeWidth: strokeWidth, redLine: redLineScheme, greenLine: greenLineScheme, blueLine: blueLineScheme);            dataAnalysis.resetAttribute();        }    else if (element.isEqualToString("rect")) {                var x:CGFloat = CGFloat((attributeDict.valueForKey("x") as NSString).floatValue), y:CGFloat = CGFloat((attributeDict.valueForKey("y")).floatValue), width:CGFloat = CGFloat((attributeDict.valueForKey("width")).floatValue), height:CGFloat = CGFloat((attributeDict.valueForKey("height")).floatValue);            var localStrokeWidth:AnyObject? = attributeDict.valueForKey("stroke-width"), fill:AnyObject? = attributeDict.valueForKey("fill"), stroke:AnyObject? = attributeDict.valueForKey("stroke");                dataAnalysis.strokeFillSet(fill?, stroke: stroke?, strokeWidthIntake: localStrokeWidth);                viewing.rectCreate(x: x, y: y, width: width, height: height, redFill: redScheme, greenFill: greenScheme, blueFill: blueScheme, alphaFill: alphaScheme, strokeWidth: strokeWidth, redLine: redLineScheme, greenLine: greenLineScheme, blueLine: blueLineScheme);            dataAnalysis.resetAttribute();        }    else if (element.isEqualToString("ellipse")) {            var cx:CGFloat = CGFloat((attributeDict.valueForKey("cx") as NSString).floatValue), yrad:CGFloat = CGFloat((attributeDict.valueForKey("ry") as NSString).floatValue), xrad:CGFloat = CGFloat((attributeDict.valueForKey("rx") as NSString).floatValue), cy:CGFloat = CGFloat((attributeDict.valueForKey("cy") as NSString).floatValue);            var localStrokeWidth:AnyObject? = attributeDict.valueForKey("stroke-width"), fill:AnyObject? = attributeDict.valueForKey("fill"), stroke:AnyObject? = attributeDict.valueForKey("stroke");                var x:CGFloat = cx - xrad, y:CGFloat = cy - yrad;            dataAnalysis.strokeFillSet(fill?, stroke: stroke?, strokeWidthIntake:localStrokeWidth);            viewing.circleCreate(x: x, y: y, widthDia: xrad*2, heightDia: yrad*2, redFill: redScheme, greenFill: greenScheme, blueFill: blueScheme, alphaFill: alphaScheme, strokeWidth: strokeWidth, redLine: redLineScheme, greenLine: greenLineScheme, blueLine: blueLineScheme);            dataAnalysis.resetAttribute();        }    else if (element.isEqualToString("polyline")) {            var points:NSString = (attributeDict.valueForKey("points") as NSString);        var localStrokeWidth:AnyObject? = attributeDict.valueForKey("stroke-width"), stroke:AnyObject? = attributeDict.valueForKey("stroke");                    dataAnalysis.polyLinePointsConvert(points);        dataAnalysis.strokeFillSet(nil, stroke: stroke?, strokeWidthIntake: localStrokeWidth?);        viewing.polyLineCreate(pointsArray: dataAnalysis.polyLinePointsConvert(points), strokeWidth: strokeWidth, redLine: redLineScheme, greenLine: greenLineScheme, blueLine: blueLineScheme);        dataAnalysis.resetAttribute();    }    else if (element.isEqualToString("text")) {        textx = CGFloat((attributeDict.valueForKey("x") as NSString).floatValue); texty = CGFloat((attributeDict.valueForKey("y") as NSString).floatValue);        var localTextSize:AnyObject? = attributeDict.valueForKey("font-size"), localFont:AnyObject? = attributeDict.valueForKey("font-family");        if (localTextSize != nil) {textFontSize = CGFloat((localTextSize as NSString).floatValue)};        if (localFont != nil) {textFontType = localFont as String};        }    else if (element.isEqualToString("polygon")){            var points:NSString = (attributeDict.valueForKey("points") as NSString);        var localStrokeWidth:AnyObject? = attributeDict.valueForKey("stroke-width"), stroke:AnyObject? = attributeDict.valueForKey("stroke");                dataAnalysis.polyLinePointsConvert(points);        dataAnalysis.strokeFillSet(nil, stroke: stroke?, strokeWidthIntake: localStrokeWidth?);        viewing.polygonCreate(pointsArray: dataAnalysis.polyLinePointsConvert(points), redFill: redScheme, greenFill: greenScheme, blueFill: blueScheme, strokeWidth: strokeWidth, redLine: redLineScheme, greenLine: greenLineScheme, blueLine: blueLineScheme);    }        }    func parser(parser: NSXMLParser!, foundCharacters string: String!) {                if (element.isEqualToString("text")){                println(string);                viewing.labelCreate(x: textx, y: texty, text: string, textSize: textFontSize*1.2, fontType: textFontType);                dataAnalysis.resetAttribute();        } else if (element.isEqualToString("title")) {                println(string);                titleHolder.append(string);        }            }}